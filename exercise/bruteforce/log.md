# 브루트 포스 연습

## 재귀
- n번째와 n+1번째 해결 방식에 특정한 패턴이 있는 경우에 사용
- 정답 찾음 / 불가능 / 다음 호출 로 경우를 나누고 보통 이 순서대로 재귀함수 코드를 작성

### 예제문제
- [6603번 로또](https://www.acmicpc.net/problem/6603)
    1. 정답 출력을 위해 전역변수로 벡터를 선언하고 push_back과 pop_back을 이용하여 정답 배열에 포함/미포함
    2. 사전순 출력을 위한 순서 -> 선택하는 것을 먼저 호출함

- [1182번 부분수열의 합](https://www.acmicpc.net/problem/1182)
    1. 재귀함수 정의에 필요한 파라미터 정의가 어려움 -> 한번씩만 선택할 수 있을 때는 지금의 인덱스만 가지고 표현 가능함
        ```
        if(idx == arr.size()) return; // 끝까지 왔음 -> 종료조건

        solve(arr, idx, sum); // 선택안함
        solve(arr, idx, sum+arr[idx]); // 선택함
        ```
    2. 중간에 sum과 s가 같아졌다고 해서 바로 끝내버리면 뒤의 배열을 전부 선택하지 않는 것과 같으므로 모든 경우의 수를 보지 않음. 끝까지 보고 판단하기
    3. 크기가 양수인 부분 수열 -> 아무것도 선택 안하는 경우 제외 -> 합이 0인 경우에 하나 빼주기

- [14225번 부분수열의 합](https://www.acmicpc.net/problem/14225)
    : 모든 경우에 대해 순서대로 O/X로 나눠지는 경우 -> 2^n의 경우 -> 전체 배열을 훑으면서 선택 or not으로 구현

- [14888번 연산자 끼워넣기](https://www.acmicpc.net/problem/14888)
    1. 하나의 선택지가 특정 수만큼 선택될 수 있는 경우 : 선택 가능 수를 감소시켜가며 각 선택에 대해 처리

- [15658번 연산자 끼워넣기 (2)](https://www.acmicpc.net/problem/15658)
    : 14888번 소스와 동일. n-1 이상을 처리해주는 부분이 따로 없었기 때문에 그대로 사용 가능

- [14500번 테트로미노](https://www.acmicpc.net/problem/14500) ([47분](./14500.cpp))
    1. **DFS와 브루트포스의 차이점** : 브루트포스는 방문 후에 다시 원래 상태로 복구하는 작업을 거치지만, (``` visit[cur] = false; ```) DFS는 복구하지 않음 -> 모든 vertex를 한 번씩 방문해야 하기 때문
    2. 배열 범위 주의 : 벡터를 n과 m의 크기로 선언한 경우 n과 m이 포함되지 않음

- [16197번 두 동전](https://www.acmicpc.net/problem/16197) ([47분](./16197.cpp))
    1. 까다로웠던 점은 두 가지 동전의 동작이 서로 다를 때를 처리하는 것이었음. 그냥 두번 처리함
    2. 범위 확인 후 이동보다 이동 후 범위 확인이 구현이 더 간편함
    2. '10보다 많이' -> 10 <= cnt