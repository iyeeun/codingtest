# 브루트 포스 연습

## 재귀
- n번째와 n+1번째 해결 방식에 특정한 패턴이 있는 경우에 사용
- 정답 찾음 / 불가능 / 다음 호출 로 경우를 나누고 보통 이 순서대로 재귀함수 코드를 작성

### 예제문제
- [6603번 로또](https://www.acmicpc.net/problem/6603)
    1. 정답 출력을 위해 전역변수로 벡터를 선언하고 push_back과 pop_back을 이용하여 정답 배열에 포함/미포함
    2. 사전순 출력을 위한 순서 -> 선택하는 것을 먼저 호출함

- [1182번 부분수열의 합](https://www.acmicpc.net/problem/1182)
    1. 재귀함수 정의에 필요한 파라미터 정의가 어려움 -> 한번씩만 선택할 수 있을 때는 지금의 인덱스만 가지고 표현 가능함
        ```
        if(idx == arr.size()) return; // 끝까지 왔음 -> 종료조건

        solve(arr, idx, sum); // 선택안함
        solve(arr, idx, sum+arr[idx]); // 선택함
        ```
    2. 중간에 sum과 s가 같아졌다고 해서 바로 끝내버리면 뒤의 배열을 전부 선택하지 않는 것과 같으므로 모든 경우의 수를 보지 않음. 끝까지 보고 판단하기
    3. 크기가 양수인 부분 수열 -> 아무것도 선택 안하는 경우 제외 -> 합이 0인 경우에 하나 빼주기

- [14225번 부분수열의 합](https://www.acmicpc.net/problem/14225)
    : 모든 경우에 대해 순서대로 O/X로 나눠지는 경우 -> 2^n의 경우 -> 전체 배열을 훑으면서 선택 or not으로 구현

- [14888번 연산자 끼워넣기](https://www.acmicpc.net/problem/14888)
    1. 하나의 선택지가 특정 수만큼 선택될 수 있는 경우 : 선택 가능 수를 감소시켜가며 각 선택에 대해 처리

- [15658번 연산자 끼워넣기 (2)](https://www.acmicpc.net/problem/15658)
    : 14888번 소스와 동일. n-1 이상을 처리해주는 부분이 따로 없었기 때문에 그대로 사용 가능

- [14500번 테트로미노](https://www.acmicpc.net/problem/14500) ([47분](./14500.cpp))
    1. **DFS와 브루트포스의 차이점** : 브루트포스는 방문 후에 다시 원래 상태로 복구하는 작업을 거치지만, (``` visit[cur] = false; ```) DFS는 복구하지 않음 -> 모든 vertex를 한 번씩 방문해야 하기 때문
    2. 배열 범위 주의 : 벡터를 n과 m의 크기로 선언한 경우 n과 m이 포함되지 않음

- [16197번 두 동전](https://www.acmicpc.net/problem/16197) ([54분](./16197.cpp))
    1. 까다로웠던 점은 두 가지 동전의 동작이 서로 다를 때를 처리하는 것이었음. 그냥 두번 처리함
    2. 범위 확인 후 이동보다 이동 후 범위 확인이 구현이 더 간편함
    2. '10보다 많이' -> 10 <= cnt

- [16198번 에너지 모으기](https://www.acmicpc.net/problem/16198) ([10분](./16198.cpp))
    : 벡터 erase와 insert 이용 -> insert 하지 않고 제거된 새로운 배열을 만들어 복원 과정 안거치게 할 수 있음

## 백트래킹
- 기본적인 브루트포스에 함수 호출을 중단하는 부분을 추가 -> 특정 조건을 만족할 때만 호출하도록 함

### 예제문제
- [9663번 N-Queen](https://www.acmicpc.net/problem/9663) ([10분](./9663.cpp))
    1. 상당히 어려웠음. 문제 해결의 포인트 -> 각 줄에 하나씩만 가능함 -> 놓을 수 있는 자리인지 검사 후 하나씩 놓기, 열에 대해 수행 (문제를 재구성)
    2. 전체 배열을 항상 검사하기보다 변수를 이용해서 조건을 확인함
        - 가로, 세로 : i와 j를 그대로 사용
        - 우측 상단으로 향하는 대각선 : i+j가 같으면 같은 줄
        - 좌측 상단으로 향하는 대각선 : n-1+i-j가 같으면 같은 줄

- [2580번 스도쿠](https://www.acmicpc.net/problem/2580) ([54분](./2580.cpp))
    1. N-Queen 문제과 유사하게 접근하면 될 것이라고 생각해서 똑같이 row 기준으로 시작했는데, 잘되지 않음 -> 한 줄에 빈칸이 여러개 있을 수 있기 때문 -> 빈칸을 벡터로 만들어 전체를 훑을 때까지 하는 것으로 바꿈
    2. 변수를 이용해서 조건 확인 - 가로, 세로, 부분 정사각형 : (i/3)*3 + (j/3)

- [4574번 스도미노쿠](https://www.acmicpc.net/problem/4574) ([65분](./4574.cpp))
    1. 도미노 확인 : set 사용, 그냥 배열 사용하는 방법도 있음 (a[i][j] = a[j][i])
    2. 재귀함수 리턴값 : void로 처리하고 그 뒤에 main에서 출력하면 정답이 안나왔음. (이유를 모르겠음) 재귀함수에서 출력하면 2번 출력될 때가 생겼음. -> bool 타입으로 바꿔주니 한 번만 출력됨 & 메인에서 출력 가능

## 순열
- **모두** 수행해야 함 + 순서가 중요함 <- 전체를 사용하는 게 아니면 선택이 필요하므로 순열로 풀 수 없음

### 예제문제
- [2529번 부등호](https://www.acmicpc.net/problem/2529) ([31분](./2529.cpp))
    1. 가장 큰 수, 가장 작은 수 -> 자릿수가 정해져있고, 한번씩 사용할 수 있다는 조건으로 인해 숫자는 정해지게 됨 (작은 수 / 큰 수부터 k+1개)
    2. 해당 숫자를 순열로 확인하며 조건을 만족하는지 체크 -> next_permutation() / prev_permutation

- [1339번 단어 수학](https://www.acmicpc.net/problem/1339) ([69분](./1339.cpp))
    : 시간 초과긴 하지만 부등호와 같은 로직으로 풀 수 있음. 최대값을 위한 수의 개수는 정해져 있다는 논리

- [14888번 연산자 끼워넣기](https://www.acmicpc.net/problem/14888) ([10분](./14888_2.cpp))
    1. next_permutation이 없으면 멈추는 코드는 뒤로 보내야 전체 순열을 확인할 수 있음

- [14889번 스타트와 링크](https://www.acmicpc.net/problem/14889) ([39분](./14889.cpp))
    1. 두 팀으로 나누기 -> 0과 1로 이루어진 순열. 전체 수를 사용하면 시간 초과남. (순열을 다 보는 건 굉장히 오래 걸리는 일)

## 비트마스크
- 숫자 S에 특정한 수 n이 포함되어 있는지 검사 : ```S & (1 << n)```
- 숫자 S에 특정한 수 n을 추가 : ```S | (1 << n)```
- 숫자 S에 특정한 수 n을 제거 : ```S & ~(1 << n)```
- 숫자 S에 특정한 수 n을 토글 : ```S ^ (1 << n)```
- 모든 부분 집합에 대하여 포함된 경우에 처리
    ```:cpp
    for(int i = 0; i < (1 << n); i ++) {
        for(int j = 0; j < n; j ++) {
            if(i & (1 << j)) {
                // j에 대해 처리
            }
        }
    }
    ```
- 선택 방법이 4가지일 때 : 4진법
    - k를 4진법으로 만들고 방법의 수를 담은 벡터를 반환하는 함수
        ```:cpp
        vector<int> gen(int k) {
            vector<int> a(LIMIT);
            for (int i=0; i<LIMIT; i++) {
                a[i] = (k&3);
                k >>= 2;
            }
            return a;
        }
        ```
    - main
        ```:cpp
        for(int i = 0; i < (1 << LIMIT*2); i ++) {
            vector<int> dirs = gen(i);
            // solve(arr, dirs); ...
        }
        ```

### 예제문제
- [14225번 부분수열의 합](https://www.acmicpc.net/problem/14225) ([8분](./14225_2.cpp))

- [1062번 가르침](https://www.acmicpc.net/problem/1062) ([55분](./1062.cpp))
    1. 알파벳 각 자리의 선택 여부를 비트마스크를 이용해 표현 : `words[i] |= (1 << (c-'a')); `
    2. 해당 단어를 선택된 알파벳을 가지고 읽을 수 있는지 판단 : `if((word & ((1 << 26)-1-mask)) == 0)`
        - (1 << 26) - 1 : 26개의 알파벳 이외의 다른 수를 지우기 위해
        - \- mask : not 연산을 수행. mask를 토글 시킴
        - word & : 해당 단어에 마스크에 not 연산을 시킨 것에 & 연산을 수행 -> 배우지 않은 글자가 단어에 들어있으면 해당 자리가 1이 됨

- [13460번 구슬 탈출 2](https://www.acmicpc.net/problem/13460) (재귀 : [48분](./13460.cpp), 비트마스크 : [12분](./13460_2.cpp))
    1. 횟수의 제한이 있음 -> 정해진 동작 k개 중 하나를 n번 고르는 것
    2. 불필요한 호출 제거 : 이전에 움직인 방향으로 또 움직이는 것, 반대 방향으로 움직이는 것 
    3. 2^n개 중 하나를 고르는 경우는 해당 비트마스크를 n자리 수 만큼 읽어 2^n진법으로 표현 가능
        - main : 모든 경우의 수 만들어서 돌리기
            ```:cpp
            for(int i = 0; i < (1 << 10*2); i ++) {
                vector<int> dir = gen(i);
                if (!valid(dir)) continue;
                solve(arr, 0, dir, red, blue);
            }
            ```
        - gen 함수 : 10진수 k를 4진법으로 변환 but 뒤집지는 않음
            ```:cpp
            vector<int> gen(int k) {
                vector<int> a(10);
                for (int i=0; i<10; i++) {
                    a[i] = (k&3);
                    k >>= 2;
                }
                return a;
            }
            ```

- [12100번 2048 (Easy)](https://www.acmicpc.net/problem/12100) (재귀 : [191분](./12100.cpp), 비트마스크 : [51분](./12100_2.cpp))
    1. 구슬 탈출 2 문제와 유사함 -> 횟수가 정해져 있음 -> 모든 경우의 수 해보기
    2. '이미 합쳐진 블록은 또 다른 블록과 다시 합쳐질 수 없다' : 해당 조건을 구현하는 가장 쉬운 방법은 합쳐진 적이 있는지를 따로 배열로 관리하는 것

## 투 포인터
- 브루트포스는 아니지만, 자연수 수열의 부분합을 계속 이용할 때 O(N)으로 구할 수 있음

### 예제문제
- [2003번 수들의 합 2](https://www.acmicpc.net/problem/2003) ([25분](./2003.cpp))
    1. 각 원소들이 자연수 -> 합을 구할 때 투 포인터 이용 가능
    2. 값이 찾는 수보다 클 때 / 작을 때 / 같을 때 구분
        <details><summary>소스코드</summary><div markdown="1">
            <pre><code>
            while (left <= right && right < n) {
                if (sum < s) {
                    right += 1;
                    sum += a[right];
                } else if (sum == s) {
                    ans += 1;
                    right += 1;
                    sum += a[right];
                } else if (sum > s) {
                    sum -= a[left];
                    left++;
                    if (left > right && left < n) {
                        right = left;
                        sum = a[left];
                    }
                }
            }
            </code></pre>
            </div></details>

- [1806번 부분합](https://www.acmicpc.net/problem/1806) ([35분](./1806.cpp))
    : 예외 처리하고 반례 찾는게 조금 까다로웠음..

- [1644번 소수의 연속합](https://www.acmicpc.net/problem/1644) ([25분](./1644.cpp))
    1. 소수 만들기 : 에라토스테네스의 체 이용 -> 투포인터로 합 구하기

## 중간에서 만나기
- 브루트포스는 아니지만, 자연수 수열의 부분합을 계속 이용할 때 O(N)으로 구할 수 있음

### 예제문제
- [1208번 부분수열의 합 2](https://www.acmicpc.net/problem/1208) ([48분](./1208.cpp))
    1. 비트마스크 이용해서 부분 수열의 합 만들어내기
    2. 투 포인터로 더해가고, 같은 수가 나오면 해당 수의 갯수를 곱하고 더하여 경우의 수를 셈

- [2143번 두 배열의 합](https://www.acmicpc.net/problem/2143) ([-분](./2143.cpp), 이진탐색 [21분](./2143_2.cpp))
    1. 연속하는 부분 수열을 만드는 과정이 까다로웠음
    2. 나머지는 위의 문제와 동일
    3. binary search로 필요한 숫자 개수 세기 (equal_range() 이용)