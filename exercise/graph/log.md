# 그래프와 BFS

## 그래프 알고리즘
- 사이클 찾기 : **이전 칸과 다른 칸으로 이동했을 때 이미 방문한 칸을 방문**했으면 사이클이 존재함
- 입력이 올바른 BFS/DFS 결과인지 파악 : 입력 순서에 따라 adjacent list를 sort하고 BFS/DFS를 수행한 결과와 같은지 확인

### 예제문제
- [16929번 Two Dots](https://www.acmicpc.net/problem/16929) ([51분](./16929.cpp))
    1. 사이클 확인 : 이전 칸과 다른 칸으로 이동했을 때 이미 방문한 칸을 방문했으면 사이클이 존재함
    2. 방문 처리 : 호출하기 전에 방문한 것으로 처리하면 안됨

- [16947번 서울 지하철 2호선](https://www.acmicpc.net/problem/16947) ([60분](./16947.cpp))
    : 역대급으로 어려웠던 문제,, 사이클을 찾기 위해 DFS를 이용하고 거리를 찾기 위해 BFS를 이용하는 문제
    1. 순환선(사이클) 확인 : 노드와 엣지의 개수가 동일 -> 딱 하나의 사이클을 가짐
        - 방법 : DFS
            1. 이전 노드로 가지 않았지만 이미 방문한 노드를 방문함
                ```
                1. 종료 조건 : 이미 방문한 노드를 방문함 -> 사이클 존재
                2. 노드 방문 처리
                3. 다음 호출 : 인접한 노드가 이전에 방문한 노드가 아니고 갈 수 있는 조건을 만족할 때, 다음을 호출
                ```
            2. 길이가 3 이상이고 이미 방문한 노드를 방문함
    2. 정점과 순환선 사이의 거리 찾기
        - 방법 : BFS
            ```
            기본적인 BFS를 이용하며 거리를 계산해줌
            1. 사이클에 속하는 노드들을 전부 큐에 넣음
            2. 각 노드의 인접한 노드들에 대해 거리가 아직 정해지지 않은 노드에만 1) 큐에 푸시 2) 길이 정함
            -> BFS이므로 처음으로 접근한 거리가 가장 최소임
            ```

- [12946번 육각 보드](https://www.acmicpc.net/problem/12946) ([55분](./12946.cpp))
    1. 육각 보드를 서로 다른 색으로 칠할 때의 색의 최대 개수 : 3
    2. 0 : 칠할 칸이 없을 때 / 1 : 칸이 서로 인접하지 않을 때 / 2 : 이분 그래프일 때 / 3 : 그 외
    3. -> 이분 그래프 판단 문제로 바뀌게 됨
        - DFS가 호출됨 -> 칸이 있음 -> 1
        - 서로 인접한 칸에 대해 2팀으로 나누어 색을 칠함 (color / -color) -> 이분그래프임 -> 2
        - 나와 같은 색이 이미 칠해진 인접 노드가 있으면 이분 그래프가 아님 -> 3

- [16940번 BFS 스페셜 저지](https://www.acmicpc.net/problem/16940) ([111분](./16940.cpp))
    1. 맨 처음에는 depth순으로 정렬하는 것으로 접근 : depth가 같은 노드 간 순서가 중요한 것이라서 틀린 답안이었음
    2. BFS를 수행하면서 순서 확인하는 방법
        ```
        1. n개의 인풋에 대해 BFS를 수행함. 이 때, 큐가 비었다면 잘못된 순서임.
        2. front가 지금 보는 인풋 노드랑 다른 경우에도 잘못된 순서임.
        3. 현재 인풋 노드의 인접 노드들 중 아직 방문하지 않은 경우에 대해 front로 parent를 설정해줌.
        4. 아까 설정해준 노드들에 대해 순서를 넘어가버리거나 인풋 노드의 parent가 front가 아닌 경우는 잘못된 순서임.
        ```
        : 이 때 인덱스 설정 등 많은 부분이 이해하기 어려웠음
    3. 입력 순서로 인접 리스트 정렬을 이용하는 방법 ([7분](./16940_2.cpp))
        ```
        1. 인접 리스트를 입력된 순서로 정렬함
        2. BFS를 진행할 때 입력 순서와 다른 경우 잘못된 순서임
        ```
        : 이 코드가 더 이해하기 쉬운듯

- [16964번 DFS 스페셜 저지](https://www.acmicpc.net/problem/16964) ([31분](./16964.cpp))
    1. BFS와 비슷하게 입력 순서로 정렬하고 DFS를 수행하여 비교함
    -> DFS 조건 때문에 잘 안됐었는데, 일단 수행하고 거르는(?) 방법을 사용하자

## BFS
- 목적 1. 모든 노드를 한 번씩 방문 2. 모든 가중치가 1일 때의 최단 거리 찾기

### 예제문제
- [16928번 뱀과 사다리 게임](https://www.acmicpc.net/problem/16928) ([39분](./16928.cpp))
    1. 중간 단계를 생략 해도 됨 -> 뱀과 사다리로 인한 이동은 따로 표시하지 않음

- [16948번 데스 나이트](https://www.acmicpc.net/problem/16948) ([7분](./16948.cpp))
    : 기본적인 BFS 문제

- [14502번 연구소](https://www.acmicpc.net/problem/14502) ([39분](./14502.cpp))
    1. 벽을 만들기 : 재귀함수를 이용하여 3개의 벽을 만들어줌. 3개가 되었을 때 안전한 영역의 개수를 셈
    2. 안전 영역 세기 : BFS를 이용하여 바이러스를 퍼트리고 퍼지지 않은 영역을 셈. 이때 배열을 복사해야만 이후의 연산에 영향이 없음
    
    => 브루트포스 + BFS, O((NM)^4)

- [12886번 돌 그룹](https://www.acmicpc.net/problem/12886) ([65분](./12886.cpp))
    1. 특정 상황 자체를 하나의 노드로 생각할 수 있음
    2. 합이 정해져있을 때, n-1개로 각 상황을 나타낼 수 있음 -> (a, b, sum-a-b)
    3. DFS/BFS를 수행할 때 전체 케이스를 모두 고려하고 있는지 파악이 필요함

- [2206번 벽 부수고 이동하기](https://www.acmicpc.net/problem/2206) ([46분](./2206_2.cpp))
    1. [첫 접근](./2206.cpp) : 벽을 하나씩 부순 후 찾아보기 -> n,m <= 1000 조건 때문에 (nm)^2이 1000000^2가 되어 시간초과가 남
    2. BFS를 수행할 때 엣지는 상황에 영향을 받으면 안됨 -> 상황을 노드에 반영 -> [행][열][벽 부숨 여부]의 3차원 배열을 이용
    3. 답을 출력할 때 벽을 부순 것과 부수지 않은 것을 비교하여 출력하는 부분이 필요함

- [16946번 벽 부수고 이동하기 4](https://www.acmicpc.net/problem/16946) ([27분](./16946.cpp))
    1. 특정 영역의 개수가 정해져있음 -> 그룹화
    2. 중복 추가 방지 : set 이용

- [14442번 벽 부수고 이동하기 2](https://www.acmicpc.net/problem/14442) ([20분](./14442.cpp))
    1. 일반화한 <벽 부수고 이동하기> 문제. 상황에 따라 행동이 바뀔 때는 한 노드의 상태로 추가하면 됨

- [16933번 벽 부수고 이동하기 3](https://www.acmicpc.net/problem/16933) ([55분](./16933.cpp))
    1. 낮/밤의 조건 추가 -> 똑같이 상태를 추가해줌
    2. 메모리 초과가 계속 났는데 vector 대신 기본 배열을 사용하니까 됐음.. 다차원 배열을 사용할 때는 기본 배열이 좋을듯

- [16954번 움직이는 미로 탈출](https://www.acmicpc.net/problem/16954) ([74분](./16954.cpp))
    1. 벽이 내려옴 -> 시간에 따라 벽의 위치를 체크 (t초 후 r, c에 있는 벽은 r-t, c에 있던 벽)
    2. 여러 가지 방법으로 접근했지만 스스로 풀지 못함. 변하는 것과 변하지 않는 것을 집중해서 찾아야 할 듯

- [16236번 아기 상어](https://www.acmicpc.net/problem/16236) ([90분](./16236.cpp))
    1. 상어가 먹을 수 있는 물고기를 찾음 : O(N^2)
    2. 그 중 하나를 선택하고 이동함 -> BFS : O(N^2)
    3. 총 O(N^4), 조건을 꼼꼼하게 보지 않아서 어려움을 겪음. 꼼꼼히 확인하자!

- [6087번 레이저 통신](https://www.acmicpc.net/problem/6087) ([분](./6087.cpp))
    1. 상어가 먹을 수 있는 물고기를 찾음 : O(N^2)
    2. 그 